import { compile, Options } from 'json-schema-to-typescript';
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import prettier from 'prettier';
import { ParsedSchema } from './parser.js';
import { logger } from '../utils/logger.js';
import { exists } from '../utils/fs.js';

/**
 * Options for type generation
 */
export type TypeGenerationOptions = {
  outputPath: string;
  prettier?: boolean;
  banner?: string;
  prefix?: string;
  suffix?: string;
  force?: boolean;
  compilerOptions?: Options;
  fileNaming?: 'kebab' | 'camel' | 'pascal' | 'snake';
  singleFile?: boolean;
  singleFileName?: string;
}

/**
 * Result of type generation
 */
export type TypeGenerationResult = {
  fileCount: number;
  files: string[];
  success: boolean;
}

/**
 * Generate TypeScript types from the parsed schema
 * 
 * @param schema The parsed schema
 * @param options Type generation options
 * @returns Result of the type generation process
 */
export async function generateTypes(
  schema: ParsedSchema | null,
  options: TypeGenerationOptions
): Promise<TypeGenerationResult> {
  const result: TypeGenerationResult = {
    fileCount: 0,
    files: [],
    success: false
  };

  try {
    if (!schema) {
      throw new Error('Invalid schema: Schema is null or undefined');
    }

    await mkdir(options.outputPath, { recursive: true });

    // @ts-ignore
    const compilerOptions: Options = {
      bannerComment: options.banner || 
        `/**\n * This file was automatically generated by usagi-ts\n * DO NOT MODIFY DIRECTLY\n */`,
      style: {
        singleQuote: true,
        semi: true,
        tabWidth: 2,
        printWidth: 100
      },
      ...options.compilerOptions
    };

    if (options.singleFile) {
      const fileName = options.singleFileName || 'index.ts';
      const filePath = path.join(options.outputPath, fileName);

      if (await exists(filePath) && !options.force) {
        throw new Error(`File already exists: ${filePath}. Use --force to overwrite.`);
      }

      let fullTypeContent = '';

      for (const typeName of schema.rootTypes) {
        const typeSchema = {
          ...schema.definitions[typeName],
          $schema: schema.version,
          title: typeName
        };

        const formattedTypeName = `${options.prefix || ''}${typeName}${options.suffix || ''}`;
        
        const typeContent = await compile(typeSchema, formattedTypeName, compilerOptions);
        fullTypeContent += typeContent + '\n\n';
      }

      if (options.prettier !== false) {
        const prettierConfig = await prettier.resolveConfig(process.cwd()) || {};
       // @ts-ignore
        fullTypeContent = prettier.format(fullTypeContent, {
          ...prettierConfig,
          parser: 'typescript'
        });
      }

      await writeFile(filePath, fullTypeContent);
      
      result.fileCount = 1;
      result.files.push(fileName);
      result.success = true;
    } else {
      for (const typeName of schema.rootTypes) {
        const typeSchema = {
          ...schema.definitions[typeName],
          $schema: schema.version,
          title: typeName
        };

        const formattedTypeName = `${options.prefix || ''}${typeName}${options.suffix || ''}`;
        
        let fileName: string;
        switch (options.fileNaming) {
          case 'camel':
            fileName = `${camelCase(typeName)}.ts`;
            break;
          case 'pascal':
            fileName = `${pascalCase(typeName)}.ts`;
            break;
          case 'snake':
            fileName = `${snakeCase(typeName)}.ts`;
            break;
          case 'kebab':
          default:
            fileName = `${kebabCase(typeName)}.ts`;
        }

        const filePath = path.join(options.outputPath, fileName);

        if (await exists(filePath) && !options.force) {
          logger.warn(`Skipping ${fileName}: File already exists. Use --force to overwrite.`);
          continue;
        }

        const typeContent = await compile(typeSchema, formattedTypeName, compilerOptions);
        
        let formattedContent = typeContent;
        if (options.prettier !== false) {
          const prettierConfig = await prettier.resolveConfig(process.cwd()) || {};
          // @ts-ignore
          formattedContent = prettier.format(typeContent, {
            ...prettierConfig,
            parser: 'typescript'
          });
        }

        await writeFile(filePath, formattedContent);
        
        result.fileCount++;
        result.files.push(fileName);
      }
      
      result.success = true;
    }

    return result;
  } catch (error) {
    logger.error('Error generating types:', error);
    return result;
  }
}

function camelCase(str: string): string {
  return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter, index) => 
    index === 0 ? letter.toLowerCase() : letter.toUpperCase()
  ).replace(/\s+/g, '');
}

function pascalCase(str: string): string {
  return str.replace(/(?:^\w|[A-Z]|\b\w)/g, letter => letter.toUpperCase())
    .replace(/\s+/g, '');
}

function snakeCase(str: string): string {
  return str.replace(/\W+/g, ' ')
    .split(/ |\B(?=[A-Z])/)
    .map(word => word.toLowerCase())
    .join('_');
}

function kebabCase(str: string): string {
  return str.replace(/\W+/g, ' ')
    .split(/ |\B(?=[A-Z])/)
    .map(word => word.toLowerCase())
    .join('-');
}
